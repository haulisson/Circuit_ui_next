# ADR-003 — Estratégia de Testes de Domínio e Adapters Mockados

- **Status**: Accepted
- **Data**: 2025-09-14
- **Decisores**: Arquitetura/Engenharia
- **Contexto**: Circuit_ui_next (re-implementação do Circuit-Sandbox com Hexagonal + DDD leve)

## Contexto
Queremos iniciar TDD pela **camada de Domínio** (Components/Wires), mantendo independência de UI (Canvas/DOM) e de persistência/simulação. Há código legado em JS (Component.js, Wire.js, Component.Resistor.js etc.) que servirá como referência comportamental, mas a nova camada de domínio será escrita em **TypeScript**. Precisamos de uma base de testes previsível, rápida e portável.

## Decisão
1. **Framework de testes**: **Vitest** (TS-first, execução rápida, API compatível com Jest).
2. **Escopo inicial de testes (domínio puro)**:
   - Fábricas: `createResistor(id, x, y)`, `createWire(id)`.
   - Componente: seleção (`isSelected`, `select`, `deselect`), acesso a portas (`getPorts`), serialização (`toJSON`).
   - Wire: `connect(a, b)` (entre `PortRef`s), `toJSON` com `orthogonal: true` no MVP.
3. **Convivência com legado**: `tsconfig.json` com `allowJs: true` temporário para migração progressiva.
4. **Adapters mockados**:
   - **RendererPort** (ex.: `IRenderer`), **PersistencePort** (ex.: `ISchematicStore`), **SimulationPort**.
   - Nos testes, usar **mocks/stubs** dessas portas. Nenhum teste deve requerer DOM/Canvas.
5. **Organização**:
   - Domínio em `src/domain/schematic/*` (TS).
   - Testes em `tests/**/*.test.ts`.
   - Comando único: `pnpm test` e `pnpm test:watch`.

## Racional
- Vitest simplifica o setup TS e mantém o ciclo TDD rápido.
- Começar por domínio puro evita que decisões de UI ou de persistência acoplem regras de negócio.
- Mocks garantem isolamento e repetibilidade dos testes.
- `allowJs` facilita leitura e paridade com o legado enquanto migramos.

## Consequências
**Positivas**
- Testes estáveis e rápidos (sem DOM).
- Facilidade para evoluir para Adapters (UI, Persistência, Simulação) sem quebrar o domínio.
- Serialização `ComponentJSON`/`WireJSON` vira contrato para export/import/autosave.

**Negativas / Riscos**
- `allowJs` pode ocultar problemas de tipagem no curto prazo.
- Divergência temporária entre comportamento do legado e o novo domínio até consolidarmos fixtures.
- Mocks pobres podem mascarar integrações reais; exigem disciplina de contrato.

## Alternativas Consideradas
- **Jest**: mais pesado no setup para TS ESM; sem ganho relevante aqui.
- **Playwright para integração**: adequado só quando a UI estiver disponível.
- **Mocha/Chai**: maior custo de montagem comparado ao Vitest.

## Implementação (mínima)
- `package.json`: scripts `test` e `test:watch` (Vitest).
- `tsconfig.json`: `strict: true`, `allowJs: true`, `paths` com `@domain/*`.
- `vitest.config.ts`: `environment: "node"`.
- Teste inicial `tests/Resistor.test.ts` cobrindo: criação, portas, seleção, conexão via `Wire`, `toJSON`.

## Migração e Desacoplamento
- Cada funcionalidade migrada do legado JS ganha um teste de paridade no domínio TS.
- Ao substituir o comportamento em TS, removemos o uso do respectivo módulo JS na rota crítica.

## Métricas de Aceitação
- `pnpm test` verde no pipeline CI local.
- Cobertura mínima 70% na pasta `src/domain/schematic` no fim do MVP (alvo progressivo).

## Itens em Aberto
- Definir fixture padrão de `Resistor` (posições/portas canônicas).
- Formalizar contrato `IRenderer` e `ISchematicStore` (ver ADR-004).

