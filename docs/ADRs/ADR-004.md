# ADR-004 — Fronteiras entre Domain, Application e Adapters (Hexagonal)

- **Status**: Accepted
- **Data**: 2025-09-14
- **Decisores**: Arquitetura/Engenharia
- **Contexto**: Circuit_ui_next (Next+TS, Canvas2D como primeiro renderer)

## Contexto
Precisamos explicitar as fronteiras da arquitetura **Hexagonal** para suportar remanufatura/expansão: domínio testável, Application orquestrando casos de uso e Adapters substituíveis (UI/Render/Persistência/Simulação). O Canvas2D será o primeiro Renderer, mas deverá ser **plugável**.

## Decisão
1. **Camadas**
   - **Domain** (`src/domain/schematic/*`): entidades, valores, regras e fábricas (`createResistor`, `createWire`). **Sem dependência** de UI/IO.
   - **Application** (`src/app/usecases/*`): **casos de uso** (ex.: `PlaceComponent`, `DrawWire`, `SelectEntities`, `ExportJSON`, `ImportJSON`). Depende **apenas de portas**.
   - **Ports** (`src/ports/*`):
     - `IRenderer` (driven): `drawComponent(c)`, `drawWire(w)`, `highlight(node)`, `clear()`, etc.
     - `ISchematicStore` (driven): `save(json)`, `load(): json`.
     - `IClock`/`IUndoRedo`/`ISimRunner` (conforme evoluir).
   - **Adapters** (`src/adapters/*`): implementações concretas das portas (Canvas2D, LocalStorage/IndexedDB, Simulação/cktsim, etc.).
2. **Fluxo**
   - UI (driver) → **Application** (caso de uso) → **Domain** (regras) → **Ports** (interfaces) → **Adapters** (implementação).
   - Application recebe **DTOs** simples; Domain expõe **JSON canônico** (`ComponentJSON`, `WireJSON`, `SchematicJSON`).
3. **Contratos/DTOs**
   - `ComponentJSON`:
     ```ts
     { id: string; type: string; x: number; y: number; ports: Array<{id: string; kind: "in"|"out"|"bidir"}>; selected: boolean }
     ```
   - `WireJSON`:
     ```ts
     { id: string; a: {componentId: string; portId: string}; b: {componentId: string; portId: string}; orthogonal: boolean }
     ```
4. **Compatibilidade com Legado**
   - Introduzir **Anti-Corruption Layer** (ACL) opcional em `src/adapters/legacy/*` para converter estruturas do legado (e.g., listas e formatos de `Component.js/Wire.js`) para DTOs do domínio e vice-versa.

## Racional
- Explicitar Ports/Adapters reduz acoplamento e permite trocar Renderer (Canvas2D → WebGL/SVG) e Persistência (LocalStorage → IndexedDB/Filesystem) sem tocar o domínio.
- Application concentra orquestração, mantendo o domínio pequeno, coeso e testável.

## Consequências
**Positivas**
- Testabilidade isolada do domínio (TDD).
- Evolução segura de UI/Renderer sem quebrar regras.
- Facilidade para CI/CD focado em contratos.

**Negativas / Riscos**
- Mais arquivos/boilerplate (ports/adapters).
- Exige disciplina para não “vazar” dependências de UI para o domínio.
- ACL de legado pode introduzir custo de manutenção temporário.

## Alternativas Consideradas
- Camadas “MVC” acopladas à UI: maior fricção para reuso e testes.
- “Clean Architecture” completa: próxima do Hexagonal; manteremos versão leve e pragmática.

## Diretrizes de Implementação
- **Domain**: sem `window`, `document`, Canvas ou APIs Web. Somente tipos TS e regras.
- **Application**: casos de uso puros, dependem apenas de **ports** (injeção por construtor).
- **Adapters**: uma pasta por tecnologia (ex.: `adapters/renderer/canvas2d`, `adapters/store/localstorage`).
- **Erro e Logs**: Application traduz exceções do domínio e das portas para erros de alto nível.

## Exemplo de Port (esboço)
```ts
// src/ports/IRenderer.ts
export interface IRenderer {
  clear(): void;
  drawComponent(cmp: ComponentJSON): void;
  drawWire(w: WireJSON): void;
  highlight(node: { x: number; y: number }): void;
}
